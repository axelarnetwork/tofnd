use super::{addr, gg20, proto, Deliverer, Party, PartyMap, SenderReceiver};
use std::convert::TryFrom;
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::{
    net::TcpListener,
    sync::mpsc::{Receiver, Sender},
    task::JoinHandle,
};
use tonic::{server, Request};

// TODO temporary to satisfy clippy
type ServerPair = (JoinHandle<()>, tokio::sync::oneshot::Sender<()>);

// #[derive(Debug)]
struct TofndParty {
    // party_map: Option<PartyMap>,
    // shutdown_sender: tokio::sync::oneshot::Sender<()>,
    // server_handle: JoinHandle<Result<(), tonic::transport::Error>>,
    client: proto::gg20_client::Gg20Client<tonic::transport::Channel>,
    server: Option<ServerPair>, // (server_handle, shutdown_sender)
    server_port: u16,
    // tx: Sender<proto::MessageIn>,
    // rx: Option<Receiver<proto::MessageIn>>,
}

pub(super) async fn new() -> impl Party {
    // start server
    let (shutdown_sender, shutdown_receiver) = tokio::sync::oneshot::channel::<()>();
    let my_service = gg20::new_service();
    let proto_service = proto::gg20_server::Gg20Server::new(my_service);
    let incoming = TcpListener::bind(addr(0).unwrap()).await.unwrap(); // use port 0 and let the OS decide
    let server_addr = incoming.local_addr().unwrap();
    let server_port = server_addr.port();
    println!("new party bound to port [{:?}]", server_port);
    // let (startup_sender, startup_receiver) = tokio::sync::oneshot::channel::<()>();
    let server_handle = tokio::spawn(async move {
        tonic::transport::Server::builder()
            .add_service(proto_service)
            .serve_with_incoming_shutdown(incoming, async {
                shutdown_receiver.await.unwrap();
            })
            .await
            .unwrap();
        // startup_sender.send(()).unwrap();
    });

    // let (tx, rx) = tokio::sync::mpsc::channel(4);

    // TODO get the server to notify us after it's started, or perhaps just "yield" here
    println!(
        "new party [{}] TODO sleep waiting for server to start...",
        server_port
    );
    tokio::time::delay_for(std::time::Duration::from_millis(100)).await;
    // startup_receiver.await.unwrap();
    // println!("party [{}] server started!", init.party_uids[my_id_index]);

    println!("new party [{}] connect to server...", server_port);
    let client = proto::gg20_client::Gg20Client::connect(format!("http://{}", server_addr))
        .await
        .unwrap();

    TofndParty {
        // party_map: None,
        client,
        server: Some((server_handle, shutdown_sender)),
        // shutdown_sender,
        // server_handle,
        server_port,
        // tx,
        // rx: Some(rx),
    }
}

#[tonic::async_trait]
impl Party for TofndParty {
    // TODO execute_keygen(init, tx, rx, deliverer)
    // tx,rx generated by the delivery, which holds a copy of each party's tx
    // each delivery lives only for one protocol instance because the rx's are destroyed at the end of each instance
    async fn execute_keygen(
        &mut self,
        init: proto::KeygenInit,
        channels: SenderReceiver,
        mut deliverer: Deliverer,
    ) {
        let my_uid = init.party_uids[usize::try_from(init.my_party_index).unwrap()].clone();
        let my_display_name = format!("{}:{}", my_uid, self.server_port); // uid:port
        let (mut keygen_server_incoming, rx) = channels;
        let mut keygen_server_outgoing = self
            .client
            .keygen(Request::new(rx))
            .await
            .unwrap()
            .into_inner();

        // the first outbound message is keygen init info
        keygen_server_incoming
            .send(proto::MessageIn {
                data: Some(proto::message_in::Data::KeygenInit(init)),
            })
            .await
            .unwrap();

        while let Some(msg) = keygen_server_outgoing.message().await.unwrap() {
            let msg_type = msg.data.as_ref().expect("missing data");

            match msg_type {
                proto::message_out::Data::Traffic(_) => {
                    deliverer.deliver(&msg, &my_uid).await;
                }
                proto::message_out::Data::KeygenResult(_) => {
                    println!("party [{}] keygen finished!", my_display_name);
                    break;
                }
                _ => panic!("bad outgoing message type"),
            };
        }
        println!("party [{}] execution complete", my_display_name);
    }

    async fn close(&mut self) {
        let (server_handle, shutdown_sender) = self.server.take().expect("missing server");
        shutdown_sender.send(()).unwrap(); // tell the server to shut down
        server_handle.await.unwrap(); // wait for server to shut down
        println!("party [{}] shutdown success", self.server_port);
    }
}
